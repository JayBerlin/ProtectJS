<!DOCTYPE html>
<html>
<head>
	<title>ProtectJS Demo</title>
	<link rel="stylesheet" href="css/app.css" />
	<link rel="stylesheet" href="libs/highlightJS/styles/docco.css" />
	<script type="text/javascript" src="libs/highlightJS/highlight.pack.js"></script>
	<script type="text/javascript" src="../ProtectJS/protect.js"></script>
	<script type="text/javascript" src=js/app.js></script>
</head>
<body>
<h1>ProtectJS</h1>
<div class="section">
<p>
	ProtectJS is clever tool that protects objects at the class level. The main objective is to allow private methods on the prototype chain, which is something JavaScript lacks. Currently developers enclose their functions to make them private, increasing memory used by the browser when more than one instance is created. ProtectJS prevents this by adding additional checks to private methods. This allows the method to know who called it and acts accordingly based on the result.
</p>
<p>
	Below is a brief example of how ProtectJS works...
</p>
<p>
	First off, we build a basic class object and then create a new instance of it so that we can call it's methods.
</p>
<pre>
	<code>
// Create the object
function MyObject() {}

// Add methods to the prototype
MyObject.prototype = {

  // This is our public method
  public: function () {
    console.log('PUBLIC method has been called');
  },

  // This is our private method, using (_)
  _private: function () {
    console.log('PRIVATE method has been called');
  }
}

// Create an instance of the object
var mo = new MyObject();

// Call its methods
mo.public(); // Pass
mo._private(); // Pass

	</code>
</pre>
<p>
  As you'd expect, you can call both methods without any issue.
</p>
<pre>
	1. <span style="color:#333">PUBLIC method has been called</span>
	2. <span style="color:#333">PRIVATE method has been called</span>
</pre>
<p>
  Now let's protect it with ProtectJS...
</p>
<pre>
	<code>
var MyObject = (function () {

  // Create the object
  function MyObject() {}

  // Add methods to the prototype
  MyObject.prototype = {

    // This is our public method
    public: function () {
      console.log('PUBLIC method has been called');
    },

    // This is our private method, using (_)
    _private: function () {
      console.log('PRIVATE method has been called');
    }
  }

  return protect(MyObject);

})();

// Create an instance of the object
var mo = new MyObject();

// Call its methods
mo.public(); // Pass
mo._private(); // Fail

	</code>
</pre>
<p>
  The object/class creation is slightly different here, we've enclosed the creation of the object inside a function. This is so that we can return a protected object.
</p>
<p>
  Creating an instance of this object and calling its methods has a different outcome this time, the private method has failed because of ProtectJS' protection.
</p>
<pre>
	1. <span style="color:#333">PUBLIC method has been called</span>
	2. <span style="color:red">Uncaught You cannot call a private method</span>
</pre>
<p>
	The only way to call a private method now, is to do it via a public one.
</p>
<pre>
	<code>
var MyObject = (function () {

  // Create the object
  function MyObject() {}

  // Add methods to the prototype
  MyObject.prototype = {

    // This is our public method
    public: function () {
      console.log('PUBLIC method has been called');

      // Let's call the private method
      this._private();
    },

    // This is our private method, using (_)
    _private: function () {
      console.log('PRIVATE method has been called');
    }
  }

  return protect(MyObject);

})();

// Create an instance of the object
var mo = new MyObject();

// Use public method to call private method
mo.public();

	</code>
</pre>
<p>
	This time the call has been allowed and has logged both messages to the console.
</p>
<pre style="margin-bottom: 60px;">
	1. <span style="color:#333">PUBLIC method has been called</span>
	2. <span style="color:#333">PRIVATE method has been called</span>
</pre>
</div>
<div class="section">
<h2>Examples</h2>
<h3>Basic public/private example</h3>
<p>
	This example is a working version of the above snippet, albeit slightly altered to show you the differences. You will be able to click on all but 'Private' as this will throw an error in your console due to the protection applied.
</p>
<script type="text/javascript">
  function logMethodCall(name) {
    console.log('\'' + name + '\'  has been called');
    alert('\'' + name + '\'  has been called');
  }
  //protect.options.obfuscatePrivateMethods = true;
	var MyObject = (function () {
    function MyObject() {}
      MyObject.prototype = {
        public: function () {
          logMethodCall('public');
        },
        publicCallsPrivate: function () {
          logMethodCall('publicCallsPrivate');
          this._private();
        },
        privateCallsPrivate: function () {
          logMethodCall('privateCallsPrivate');
          this._privateCallsPrivate();
        },
        _privateCallsPrivate: function () {
          logMethodCall('_privateCallsPrivate');
          this._private();
        },
        _private: function () {
          logMethodCall('_private');
        }
    }
  return protect(MyObject);
})();

var mo = new MyObject();
</script>
<div class="example-1-buttonWrapper">
	<div onclick="mo.public()">Public</div>
	<div onclick="mo._private()">Private</div>
  <div onclick="mo.publicCallsPrivate()">Public calls Private</div>
  <div onclick="mo.privateCallsPrivate()">Private calls Private</div>
</div>
</div>
<script type="text/javascript">
  function extend() {
    protect.extend(MyObject, {
      sayHi: function () {
        this._sayHi();
      },
      _sayHi: function () {
        console.log('Hi');
        alert('Hi');
      }
    });
  }
  function override() {
    protect.override(MyObject, {
      _private: function () {
        console.log('PRIVATE');
        alert('PRIVATE');
      }
    });
  }
</script>
<div class="section">
<h3>Extending protected objects</h3>
<p>
  ProtectJS has an extend method which allows you or another developer to extend an already protected object.
  The snippet below will add two new methods to the object, one public and one private. Calling the <b>sayHi</b> method will call the private <b>_sayHi</b> method and alert you with 'Hi'. Try it out below. You will notice it will only work if you've extended the object first.
</p>
<pre>
  <code>
protect.extend(MyObject, {
  sayHi: function () {
    this._sayHi();
  },
  _sayHi: function () {
    console.log('Hi');
    alert('Hi');
  }
});
  </code>
</pre>
<div class="example-2-buttonWrapper">
  <div onclick="extend()">Extend</div>
  <div onclick="mo.sayHi()">Say 'Hi'</div>
</div>
</div>
<div class="section">
<h3>Overriding protected methods</h3>
<p>
  ProtectJS has an override method which allows you or another developer to override any method within an already protected object.
  Let's change the <b>_private</b> method to alert you with 'PRIVATE'. Try it out below. You will notice it will only work if you override the object first.
</p>
<pre>
  <code>
protect.override(MyObject, {
  _private: function () {
    console.log('PRIVATE');
    alert('PRIVATE');
  }
});
  </code>
</pre>
<div class="example-2-buttonWrapper">
  <div onclick="override()">Override</div>
  <div onclick="mo.publicCallsPrivate()">Public call Private</div>
</div>
</div>
<div class="section">
<h2>Options</h2>
There is only one option so far and that is to obfuscate private method names...
<pre>
	<code>
protect.options.obfuscatePrivateMethods = true;
	</code>
</pre>
</div>
</body>
</html>